#!/usr/bin/env node\n\n/**\n * Custom MCP Server for Thought Chat Interface\n * \n * This gives you complete control over:\n * - Message processing and AI routing\n * - User authentication and session management\n * - Data storage and conversation history\n * - Custom voice processing and synthesis\n * - Integration with external services\n * \n * Run with: node mcp-server.js\n */\n\nconst WebSocket = require('ws');\nconst express = require('express');\nconst { createServer } = require('http');\nconst cors = require('cors');\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst fs = require('fs').promises;\nconst path = require('path');\n\nclass ThoughtChatMCP {\n    constructor() {\n        this.app = express();\n        this.server = createServer(this.app);\n        this.wss = new WebSocket.Server({ server: this.server });\n        \n        this.sessions = new Map();\n        this.conversations = new Map();\n        this.aiProviders = new Map();\n        \n        this.setupMiddleware();\n        this.setupRoutes();\n        this.setupWebSocket();\n        this.initializeAIProviders();\n    }\n\n    setupMiddleware() {\n        this.app.use(cors());\n        this.app.use(express.json({ limit: '10mb' }));\n        this.app.use(express.static('public'));\n        \n        // Custom authentication middleware\n        this.app.use('/api/protected', this.authenticateToken.bind(this));\n    }\n\n    setupRoutes() {\n        // Authentication\n        this.app.post('/api/auth/signin', this.handleSIWELogin.bind(this));\n        this.app.post('/api/auth/logout', this.handleLogout.bind(this));\n        \n        // Chat endpoints\n        this.app.post('/api/chat/message', this.handleChatMessage.bind(this));\n        this.app.get('/api/chat/history/:sessionId', this.getChatHistory.bind(this));\n        \n        // Voice processing\n        this.app.post('/api/voice/transcribe', this.transcribeAudio.bind(this));\n        this.app.post('/api/voice/synthesize', this.synthesizeVoice.bind(this));\n        \n        // User data management\n        this.app.get('/api/protected/profile', this.getUserProfile.bind(this));\n        this.app.post('/api/protected/export', this.exportUserData.bind(this));\n        this.app.delete('/api/protected/data', this.deleteUserData.bind(this));\n        \n        // AI provider selection\n        this.app.post('/api/protected/ai-provider', this.setAIProvider.bind(this));\n        this.app.get('/api/ai-providers', this.getAvailableProviders.bind(this));\n    }\n\n    setupWebSocket() {\n        this.wss.on('connection', (ws, req) => {\n            console.log('New WebSocket connection');\n            \n            ws.on('message', async (data) => {\n                try {\n                    const message = JSON.parse(data);\n                    await this.handleWebSocketMessage(ws, message);\n                } catch (error) {\n                    console.error('WebSocket message error:', error);\n                    ws.send(JSON.stringify({ error: 'Invalid message format' }));\n                }\n            });\n\n            ws.on('close', () => {\n                console.log('WebSocket connection closed');\n            });\n        });\n    }\n\n    async handleWebSocketMessage(ws, message) {\n        switch (message.type) {\n            case 'auth':\n                await this.authenticateWebSocket(ws, message.token);\n                break;\n            case 'chat':\n                await this.processRealtimeChat(ws, message);\n                break;\n            case 'voice-start':\n                await this.startVoiceProcessing(ws, message);\n                break;\n            case 'voice-data':\n                await this.processVoiceData(ws, message);\n                break;\n            case 'voice-end':\n                await this.endVoiceProcessing(ws, message);\n                break;\n            default:\n                ws.send(JSON.stringify({ error: 'Unknown message type' }));\n        }\n    }\n\n    async handleSIWELogin(req, res) {\n        try {\n            const { message, signature } = req.body;\n            \n            // Verify SIWE signature\n            const isValid = await this.verifySIWESignature(message, signature);\n            if (!isValid) {\n                return res.status(401).json({ error: 'Invalid signature' });\n            }\n            \n            // Extract address from message\n            const address = this.extractAddressFromSIWE(message);\n            \n            // Generate session token\n            const sessionId = crypto.randomUUID();\n            const token = jwt.sign(\n                { address, sessionId },\n                process.env.JWT_SECRET || 'your-secret-key',\n                { expiresIn: '24h' }\n            );\n            \n            // Store session\n            this.sessions.set(sessionId, {\n                address,\n                createdAt: Date.now(),\n                lastActive: Date.now(),\n                preferences: await this.loadUserPreferences(address)\n            });\n            \n            res.json({ token, sessionId, address });\n        } catch (error) {\n            console.error('SIWE login error:', error);\n            res.status(500).json({ error: 'Authentication failed' });\n        }\n    }\n\n    async handleChatMessage(req, res) {\n        try {\n            const { message, sessionId, options = {} } = req.body;\n            \n            if (!sessionId || !this.sessions.has(sessionId)) {\n                return res.status(401).json({ error: 'Invalid session' });\n            }\n            \n            const session = this.sessions.get(sessionId);\n            const conversationId = options.conversationId || `${sessionId}-default`;\n            \n            // Get or create conversation\n            let conversation = this.conversations.get(conversationId) || {\n                id: conversationId,\n                sessionId,\n                messages: [],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            };\n            \n            // Add user message\n            conversation.messages.push({\n                role: 'user',\n                content: message,\n                timestamp: Date.now()\n            });\n            \n            // Generate AI response\n            const aiProvider = session.preferences?.aiProvider || 'default';\n            const response = await this.generateAIResponse(message, conversation, aiProvider);\n            \n            // Add assistant message\n            conversation.messages.push({\n                role: 'assistant',\n                content: response,\n                timestamp: Date.now()\n            });\n            \n            // Update conversation\n            conversation.updatedAt = Date.now();\n            this.conversations.set(conversationId, conversation);\n            \n            // Save to persistent storage\n            await this.saveConversation(conversation);\n            \n            res.json({ response, conversationId });\n        } catch (error) {\n            console.error('Chat message error:', error);\n            res.status(500).json({ error: 'Failed to process message' });\n        }\n    }\n\n    async transcribeAudio(req, res) {\n        try {\n            const { audioData, format = 'webm' } = req.body;\n            \n            // Use Whisper API or local transcription\n            const transcript = await this.performTranscription(audioData, format);\n            \n            res.json({ transcript });\n        } catch (error) {\n            console.error('Transcription error:', error);\n            res.status(500).json({ error: 'Transcription failed' });\n        }\n    }\n\n    async synthesizeVoice(req, res) {\n        try {\n            const { text, voice = 'default', speed = 1.0 } = req.body;\n            \n            // Use TTS service or local synthesis\n            const audioData = await this.performTTS(text, { voice, speed });\n            \n            res.json({ audioData });\n        } catch (error) {\n            console.error('TTS error:', error);\n            res.status(500).json({ error: 'Voice synthesis failed' });\n        }\n    }\n\n    async exportUserData(req, res) {\n        try {\n            const { address } = req.user;\n            \n            const data = {\n                profile: await this.loadUserPreferences(address),\n                conversations: await this.getUserConversations(address),\n                voiceSettings: await this.getUserVoiceSettings(address),\n                exportDate: new Date().toISOString()\n            };\n            \n            res.json({ data });\n        } catch (error) {\n            console.error('Data export error:', error);\n            res.status(500).json({ error: 'Export failed' });\n        }\n    }\n\n    async deleteUserData(req, res) {\n        try {\n            const { address } = req.user;\n            const { confirmSignature } = req.body;\n            \n            // Verify deletion signature\n            const isValid = await this.verifyDeletionSignature(address, confirmSignature);\n            if (!isValid) {\n                return res.status(401).json({ error: 'Invalid deletion signature' });\n            }\n            \n            // Delete all user data\n            await this.purgeUserData(address);\n            \n            res.json({ success: true });\n        } catch (error) {\n            console.error('Data deletion error:', error);\n            res.status(500).json({ error: 'Deletion failed' });\n        }\n    }\n\n    initializeAIProviders() {\n        // Default local responses\n        this.aiProviders.set('default', {\n            name: 'Default Response Engine',\n            generate: this.generateDefaultResponse.bind(this)\n        });\n        \n        // OpenAI integration\n        if (process.env.OPENAI_API_KEY) {\n            this.aiProviders.set('openai', {\n                name: 'OpenAI GPT',\n                generate: this.generateOpenAIResponse.bind(this)\n            });\n        }\n        \n        // Local LLM integration\n        this.aiProviders.set('local', {\n            name: 'Local LLM',\n            generate: this.generateLocalResponse.bind(this)\n        });\n    }\n\n    async generateAIResponse(message, conversation, provider = 'default') {\n        const aiProvider = this.aiProviders.get(provider);\n        if (!aiProvider) {\n            throw new Error(`Unknown AI provider: ${provider}`);\n        }\n        \n        return await aiProvider.generate(message, conversation);\n    }\n\n    async generateDefaultResponse(message, conversation) {\n        const responses = [\n            `I understand you're thinking about: \"${message}\". Let me reflect on that...`,\n            `That's an interesting thought about \"${message}\". Here's my perspective...`,\n            `Your thought \"${message}\" reminds me of several concepts we could explore...`,\n            `I hear your thought about \"${message}\". Let me share some insights...`\n        ];\n        \n        return responses[Math.floor(Math.random() * responses.length)];\n    }\n\n    authenticateToken(req, res, next) {\n        const authHeader = req.headers['authorization'];\n        const token = authHeader && authHeader.split(' ')[1];\n        \n        if (!token) {\n            return res.sendStatus(401);\n        }\n        \n        jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key', (err, user) => {\n            if (err) return res.sendStatus(403);\n            req.user = user;\n            next();\n        });\n    }\n\n    async verifySIWESignature(message, signature) {\n        // Implement SIWE signature verification\n        // This is a placeholder - use actual ethers.js verification\n        return true;\n    }\n\n    extractAddressFromSIWE(message) {\n        // Extract Ethereum address from SIWE message\n        const match = message.match(/0x[a-fA-F0-9]{40}/);\n        return match ? match[0] : null;\n    }\n\n    async saveConversation(conversation) {\n        const filePath = path.join(__dirname, 'data', 'conversations', `${conversation.id}.json`);\n        await fs.mkdir(path.dirname(filePath), { recursive: true });\n        await fs.writeFile(filePath, JSON.stringify(conversation, null, 2));\n    }\n\n    async loadUserPreferences(address) {\n        try {\n            const filePath = path.join(__dirname, 'data', 'users', `${address}.json`);\n            const data = await fs.readFile(filePath, 'utf8');\n            return JSON.parse(data);\n        } catch (error) {\n            return {\n                aiProvider: 'default',\n                voiceSpeed: 1.0,\n                autoSpeak: true,\n                preferredVoice: 'default'\n            };\n        }\n    }\n\n    start(port = 3000) {\n        this.server.listen(port, () => {\n            console.log(`🧠 Thought Chat MCP Server running on port ${port}`);\n            console.log(`📡 WebSocket server ready for connections`);\n            console.log(`🤖 AI providers loaded: ${Array.from(this.aiProviders.keys()).join(', ')}`);\n        });\n    }\n}\n\n// Environment setup\nrequire('dotenv').config();\n\n// Create and start server\nconst mcpServer = new ThoughtChatMCP();\nmcpServer.start(process.env.PORT || 3000);\n\nmodule.exports = ThoughtChatMCP;"